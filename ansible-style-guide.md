**Style Guide для Ansible**

> Версия документа: `1.0`<br/>
> Дата документа: `2022-02-XX`

---

[TOC]

## Форматирование (Formatting)

#### f1. Формат файла

* Кодировка: `UTF-8 without BOM`
* Символ конца строки: `LF` (Unix style)

#### f2. Конец файла

Файл всегда завершается символом перевода строки (`LF`).

#### f3. Отступы

В качестве отступа в YAML-файле используется **2** пробела. Это касается и списков.

* плохо:
  ```yaml
  - hosts: all
    roles:
    - { role: manage_repository, thirdparty_repos_enable: true }
    - { role: server_defaults }
    tags:
    - initial
    - never
  ```

* хорошо:
  ```yaml
  - hosts: all
    roles:
      - { role: manage_repository, thirdparty_repos_enable: true }
      - { role: server_defaults }
    tags:
      - initial
      - never
  ```

#### f4. Разделитель — пустая строка

Пустая строка ставится между plays, tasks, inventory-группами.

* плохо:
  ```yaml
  TODO: пример
  ```

* хорошо:
  ```yaml
  TODO: пример
  ```

#### f5. Блочные тэги Jinja2

Чтобы корректно вписать в YAML-файл блочные тэги Jinja2 (например, `{% if %}`, `{% for %}`), не поломав
отступы и не добавляя лишние пустые строки, необходимо соответствующим образом настроить Jinja2-параметры
[`lstrip_blocks`](https://jinja.palletsprojects.com/en/3.0.x/api/?highlight=lstrip_blocks#jinja2.Environment) и
[`trim_blocks`](https://jinja.palletsprojects.com/en/3.0.x/api/?highlight=trim_blocks#jinja2.Environment)
через директиву `#jinja2` в первой строке шаблона
(см. [Notes](https://docs.ansible.com/ansible/latest/collections/ansible/builtin/template_module.html#notes)
к модулю **template**):

  ```
  #jinja2: lstrip_blocks: True, trim_blocks: True
  ```

Пример:

* `docker-compose.yml.j2`:
  ```yaml
  #jinja2: lstrip_blocks: True, trim_blocks: True
  services:
    service:
      image: java-app:latest
      restart: always
      environment:
        ADMIN_MAIL_SUPPORT: hd-{{ STAND }}@it2g.ru
      {% if STAND != 'prod' %}
        JAVA_TOOL_OPTIONS: -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005
      {% endif %}
        SPRING_PROFILES_ACTIVE: std-{{ STAND }}
      ports:
        - '5005:5005'
  ```
  _Обратите внимание: блочные Jinja2-тэги располагаются со сдвигом влево относительного самого
  содержимого блока. Это позволяет визуально выделить эти тэги из общего контекста и одновременно
  сохранить реальный сдвиг содержимого блока._


* `docker-compose.yml` при `STAND == 'test'`:
  ```yaml
  services:
    service:
      image: java-app:latest
      restart: always
      environment:
        ADMIN_MAIL_SUPPORT: hd-test@it2g.ru
        JAVA_TOOL_OPTIONS: -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005
        SPRING_PROFILES_ACTIVE: std-test
      ports:
        - '5005:5005'
  ```

* `docker-compose.yml` при `STAND == 'prod'`:
  ```yaml
  services:
    service:
      image: java-app:latest
      restart: always
      environment:
        ADMIN_MAIL_SUPPORT: hd-prod@it2g.ru
        SPRING_PROFILES_ACTIVE: std-prod
      ports:
        - '5005:5005'
  ```

#### f6. Заголовок файла, содержимое которого управляется через Ansible

Если содержимое файла полностью контролируется Ansible'ом, то по возможности добавлять в него заголовок,
сигнализирующий об этом.

Например:
```
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# #  Managed by Ansible                                                     # #
# #  DO NOT EDIT THIS FILE MANUALLY                                         # #
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
```

Как правило, это касается шаблонов и текстовых файлов, целиком копируемых на хост.

## Синтаксис (Syntax)

#### s1. Boolean-значения задаются только через `true` или `false`

* плохо:
  ```yaml
  - name: Start service Nginx
    service:
      name: nginx
      enabled: 1
    become: yes
  ```

* хорошо:
  ```yaml
  - name: Start service Nginx
    service:
      name: nginx
      enabled: true
    become: true
  ```

#### s2. Скаляры обрамляются в кавычки только по необходимости

Скаляр — это [YAML-узел](https://yaml.org/spec/1.2.2/#3211-nodes), представляющий единичное значение
— _строку_, _число_, _логическое значение_ или _null_.

Для улучшения читабильности скаляры обрамляются в кавычки только если в этом возникает
реальная необходимость (см. приложение [Когда скаляр в YAML необходимо обрамлять в кавычки](#приложение-1-когда-скаляр-в-yaml-необходимо-обрамлять-в-кавычки)).

* плохо:
  ```yaml
  - name: 'Create Docker plugins directory {{ _docker_plugin_subdir }} if it does not exist'
    file:
      path: '/usr/lib/docker/{{ _docker_plugin_subdir }}'
      state: 'directory'
      mode: '755'
  ```

* хорошо:
  ```yaml
  - name: Create Docker plugins directory {{ _docker_plugin_subdir }} if it does not exist
    file:
      path: /usr/lib/docker/{{ _docker_plugin_subdir }}
      state: directory
      mode: 0755  # скаляр, начинающийся с символа '0' интерпретируется в YAML как восьмеричное число
  ```
  ```yaml
  package_distribution: '{{ ansible_distribution | lower }}'  # без кавычек будет синтаксическая ошибка YAML
  package_version: '1.0'  # без кавычек переменная примет числовое значение = 1
  column_separator: '#'   # без кавычек переменная примет значение null, так как комбинация <пробел>#
                          # служит в YAML началом комментария
  column_separator: "\t"  # без кавычек или в одинарных кавычках переменная примет строковое значение
                          # из двух символов - '\' и 't', а в двойных кавычках - знак табуляции
  ```

#### s3. Двойные кавычки `"` вместо одинарных `'` используются только по необходимости

**Двойные** кавычки `"` используются только в случае, если обрамляемая строка должна содержать
[escape-последовательности](https://yaml.org/spec/1.2.2/#escaped-characters), например:

Во всех остальных случаях используются **одинарные** кавычки `'`.

* плохо:
  ```yaml
  ```

* хорошо:
  ```yaml
  ```

#### s4. Директивы определяются только через map-синтаксис

* плохо:
  ```yaml
  - name: Copy file defaults.conf
    file: 'dest=/etc/ src=defaults.conf'
  ```

* хорошо:
  ```yaml
  - name: Copy file defaults.conf
    file:
      dest: /etc/
      src: defaults.conf
  ```

#### s5. Значения директивы `tags` всегда задаются в виде списка

Такой синтаксис позволяет легко добавлять и удалять тэги.

* плохо:
  ```yaml
  tags: common
  ```

* хорошо:
  ```yaml
  tags:
    - common
  ```

#### s6. Короткая версия записи role используется только в ограниченных случаях

Короткую версию записи **role** можно использовать только когда роль вызывается без [аргументов](#r1-аргументы-роли)
и длина строки не превышает 100 символов.

Это позволяет избегать путаницы между стандартными [role-директивами](https://docs.ansible.com/ansible/latest/reference_appendices/playbooks_keywords.html#role)
и **аргументами роли** и улучшает читабельность кода.

* плохо:
  ```yaml
  - { role: manage_repository, thirdparty_repos_enable: true, tags: [initial, never] }
  - { role: prepare_2020, delegate_to: localhost, when: ansible_date_time.year|int <= 2020, tags: [prepare, year2020] }
  ```

* хорошо:
  ```yaml
  - { role: server_defaults, tags: [initial] }
  - { role: debian_defaults, when: ansible_os_family == 'Debian', tags: [defaults, never] }

  - role: manage_repository
    vars:
      thirdparty_repos_enable: true
    tags:
      - initial
      - never

  - role: prepare_2020
    delegate_to: localhost
    when: ansible_date_time.year|int <= 2020
    tags:
      - prepare
      - year2020
  ```

## Именование (Naming)

#### n1. Стиль именования _snake_case_ для переменных, ролей, inventory-групп и файлов

Так как все стандартные модули Ansible именуются в стиле [**snake_case**](https://ru.wikipedia.org/wiki/Snake_case),
есть смысл распространить это соглашение на имена переменных, ролей и файлов.

Для inventory-групп это требование Ansible, начиная с версии 2.10.

* inventory:
  ```yaml
    children:

      app_servers:
        hosts:
          dodms-app-aio-1:
          dodms-app-aio-2:

      front_servers:
        hosts:
          dodms-oib-aio-1:
  ```

#### n2. Имена переменных в inventory всегда ЗАГЛАВНЫМИ буквами

Разумеется, это не касается служебных Ansible-переменных.

* inventory:
  ```yaml
  ---
  all:

    vars:
      ansible_user: 'root'

      LOKI_PORT: 3100
      LOKI_SERVER: '{{ hostvars[groups["loki_server"][0]].ansible_host }}'
      LOKI_URL: http://{{ LOKI_SERVER }}:{{ LOKI_PORT }}/loki/api/v1/push
      MINIO:
        ACCESS_KEY: "minio"
        SECRET_KEY: "minio123"
      STAND: test-1
  ```

#### n3. Имена extra-переменных в плейбуке всегда ЗАГЛАВНЫМИ буквами

Extra-переменные (см. [Defining variables at runtime](https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#defining-variables-at-runtime))
— это переменные плейбука, заданные через аргументы командной строки `--extra-vars` (или `-e`).

Extra-переменные необходимо описывать в комментариях в заголовке плейбука, чтобы
отделять их от переменных из inventory, которые также именуются заглавными буквами.

* плейбук:
  ```yaml
  # Плейбук зависит от переменных, задаваемых через опцию --extra-vars:
  #
  #   CICD_IMAGES_TAG - общий тэг всех docker-образов для деплоя

  - hosts: front_servers
    gather_facts: false
    roles:
      - role: dockerized-service
        vars:
          service_name: ms-dodms-ui
          service_port: 8064
          dest: /opt/{{ service_name }}
          compose: |
            services:
              service:
                image: it2g/dodms/{{ service_name }}:{{ CICD_IMAGES_TAG }}
                restart: always
                ports:
                  - '{{ service_port }}:80'
    tags:
      - ms-dodms-ui
  ```

#### n4. Имена переменных в плейбуке и в роли всегда строчными буквами

Это позволяет отделять _внешние переменные_ (inventory и extra) от всех остальных переменных.

#### n5. Имена приватных переменных роли всегда с префиксом `_` (знак подчёркивания)

Благодаря этому в исходном коде роли хорошо различаются [аргументы роли](#r1-аргументы-роли) и
[приватные переменные роли](#r3-приватные-переменные-и-подкаталог-vars), которые определяются и используются только внутри
роли.

```yaml
TODO: пример
```

#### n6. Именование registering-переменных

Registering-переменные (см. [Registering variables](https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#registering-variables))
— это переменные, сохраняющие результат выполнения task через директиву `register`.

* Префикс `r__` (два знака подчёркивания), если переменная используется в последующих tasks:
  ```yaml
  - name: Расширение {{ extension_info.name }} | Определить уже установленную версию
    shell: gnome-extensions info "{{ extension_info.uuid }}" | sed -n '/Version:/s/[^0-9.]*\([0-9.]*\).*/\1/p'
    register: r__extension_installed_version
    changed_when: false

  - name: Расширение {{ extension_info.name }} | Версия установленного: {{ r__extension_installed_version.stdout or 0 }}
    set_fact:
      _extension_version:
        installed: '{{ r__extension_installed_version.stdout or 0 }}'
        website: '{{ extension_info.version }}'
  ```

* `result`, если переменная используется _только_ в пределах task:
  ```yaml
  - name: Docker pull images
    command:
      cmd: docker-compose pull
      chdir: '{{ dest }}'
    register: result
    changed_when: "'... status: downloaded newer image' in result.stderr | default('')"
  ```

## Упорядочивание (Ordering)

#### o1. Порядок перечисления тэгов в директиве `tags`

Тэги в директиве `tags` перечисляются в **алфавитном** порядке.

* play:
  ```yaml
  TODO: пример
  ```

#### o2. Порядок перечисления хостов в директиве `hosts`

Если требуется указать несколько хостов или групп хостов в директиве `hosts`, то они перечисляются
в **алфавитном** порядке.

* play:
  ```yaml
  - hosts:
      - activemq_server
      - signing_server
      - work_calendar_server
    roles:
      ...
  ```

#### o3. Порядок перечисления хостов и групп хостов в inventory

Хосты в директиве `hosts` перечисляются в **алфавитном** порядке.

* inventory:
  ```yaml
  ---
  all:

    hosts:
      dev-db:
        ansible_host: 10.234.93.11
      dev-files:
        ansible_host: 10.234.93.12

    children:

      backoffice:
        hosts:
          dev-db:
          dev-files:
  ```

Группы и подгруппы внутри групп определяются в inventory в **алфавитном** порядке.

* inventory:
  ```yaml
  ---
  all:

    hosts:
      dev-db:
        ansible_host: 10.234.93.11
      dev-files:
        ansible_host: 10.234.93.12

    children:

      docker_registry:
        children:
          file_storage:

      nfs_server:
        hosts:

      services:
        children:

          db:
            hosts:
              dev-db:

          file_storage:
            hosts:
              dev-files:
  ```
  _Обратите внимание: группа_ `docker_registry` _ссылается на подгруппу_ `file_storage`_, которая определятся ниже._

#### o4. Порядок определения переменных

Переменные определяются в **алфавитном** порядке:
  * в **inventory**
  * у **роли** в `defaults/main.yml` и `vars/main.yml`

Внимание! Ansible позволяет в значениях переменных ссылаться на переменные, перечисленные ниже в этом же блоке определений.

Примеры:

* inventory:
  ```yaml
  TODO: пример
  ```

* `vars/main.yml`:
  ```yaml
  TODO: пример
  ```

* плейбук:
  ```yaml
  TODO: пример
  ```

#### o5. Порядок определения [аргументов роли](#r1-аргументы-роли)

В спецификации роли в `meta/main.yml` аргументы определяются в **алфавитном** порядке:

* `meta/main.yml`:
  ```yaml
  TODO: пример
  ```

#### o6. Порядок определения директив

В зависимости от типа секции, директивы (см. [Playbook Keywords](https://docs.ansible.com/ansible/latest/reference_appendices/playbooks_keywords.html))
перечисляются в следующем порядке:

<table>
<thead>
<th>

Play

</th>
<th>

Role

</th>
<th>

Task

</th>
<tr>
</thead>
<tbody>
<td valign="top">

1. `hosts`
1. остальные [play-директивы](https://docs.ansible.com/ansible/latest/reference_appendices/playbooks_keywords.html#play)<br>
   в **произвольном** порядке
1. `pre_tasks`
1. `roles` / `tasks`
1. `post_tasks`
1. `handlers`
1. `tags`

```yaml
TODO: пример
```

</td>
<td valign="top">

1. `role`
1. `vars`
   * аргументы роли<br> в **произвольном** порядке
1. остальные [role-директивы](https://docs.ansible.com/ansible/latest/reference_appendices/playbooks_keywords.html#role)<br>
   в **произвольном** порядке
1. `tags`


```yaml
TODO: пример



```

</td>
<td valign="top">

1. `name`
1. модуль
   * параметры модуля<br> в **произвольном** порядке
1. остальные [task-директивы](https://docs.ansible.com/ansible/latest/reference_appendices/playbooks_keywords.html#task)<br>
   в **произвольном** порядке
1. `tags`

```yaml
TODO: пример



```

</td>
</tr>
<tr>
<td colspan="3">

1. Секция начинается с _ключевой директивы_: `hosts`, `role` или `name` (директива `name` необязательна для модулей `import_*` и `include_*`).
1. Далее для секций **role** и **task** указывается _роль_ с аргументами или _модуль_ с соответствующими параметрами.
1. Далее следуют _остальные директивы_ секции в произвольном порядке.
1. Далее для секции **play** следуют директивы в порядке их выполнения: `pre_tasks`, `roles`, `tasks`, `post_tasks`, `handlers`
1. Последней директивой в секции указывается `tags`, если необходимо задать тэги секции.

Рекомендации:

* Одновременное использование директив `roles` и `tasks` нежелательно из-за неочевидного порядка выполнения
  (сначала выполняется `roles`, затем `tasks`).  Совместно с `roles` лучше использовать директивы `pre_tasks`
  и `post_tasks`, если необходимо выполнить какие-либо задачи _до_ и _после_ выполнения ролей.
* Одновременное использование директив `pre_tasks`, `tasks` и `post_tasks` почти всегда лишено смысла.
  Лучше использовать одну директиву `tasks`. Единственное исключение — выполнение handler'ов. Они
  выполняются отдельно в конце каждой директивы `pre_tasks`, `tasks` и `post_tasks`.

</td>
</tr>
</tbody>
</table>

## Дизайн (Design)

#### d1. Один плейбук — много стендов

Плейбук должен быть _общим_ для всех стендов (dev, stage, preprod, prod) и быть готовым к запуску
на любом стенде.

Если часть плейбука _не должна_ выполняться на определённом стенде, то в inventory этого стенда
соответствующие группы объявляются _пустыми_. Тогда все plays, связанные с этими группами,
выполняться не будут.

Пример установки RabbitMQ на всех стендах, кроме **dev**:

* плейбук - _одинаковый_ для всех стендов:
  ```yaml
  - hosts: rabbitmq_server:
    roles:
      - role: rabbitmq

  - hosts: redis_servers:
    roles:
      - role: redis
  ```

* inventory стенда **dev** - _пустая_ группа `rabbitmq_server`:
  ```yaml
  children:

    rabbitmq_server:
      hosts:

    redis_servers:
      hosts:
        app-dev-1:
        app-dev-2:
  ```

* inventory стенда **stage**:
  ```yaml
  children:

    rabbitmq_server:
      hosts:
        app-stage-1:

    redis_servers:
      hosts:
        app-stage-1:
        app-stage-2:
  ```

#### d2. Роль управляется только через свои аргументы

Роль ничего не должна знать об **inventory** или [**extra**-переменных](#n3-имена-extra-переменных-в-плейбуке-всегда-заглавными-буквами).
Если в роли необходимо реализовать inventory-зависимый функционал или использовать extra-переменные,
то все необходимые значения должны передаваться через [аргументы роли](#r1-аргументы-роли).

* play:
  ```yaml
  # Плейбук зависит от переменных, задаваемых через опцию --extra-vars:
  #
  #   CICD_IMAGES_TAG - общий тэг всех docker-образов для деплоя

  ---
  - hosts: app-servers
    gather_facts: false
    roles:
      - role: lms
        vars:
          deploy_images_tag: '{{ CICD_IMAGES_TAG }}'
          deploy_stand: '{{ STAND }}'
          xapi_service: "{{ hostvars[groups['xapi_server'][0]].ansible_host }}:8081"
    tags:
      - lms
  ```

* inventory:
  ```yaml
  all:

    vars:
      STAND: test-1

    hosts:
      app-srv-sdo-1:
        ansible_host: 172.17.40.65

    children:

      xapi_server:
        hosts:
          app-srv-sdo-1:
  ```

## Роли (Roles)

#### r1. Аргументы роли

Аргументы роли — это входные параметры роли в виде переменных, переданных в роль через директиву `vars`:

```yaml
- role: apt_thirdparty_package
  vars:
    key_url: https://apt.releases.hashicorp.com/gpg
    repo_url: https://apt.releases.hashicorp.com
    repo_component: main
    package_name: vagrant
  when:
    - ansible_os_family == 'Debian'
```

Все аргументы роли должны быть описаны в файле `meta/main.yml`, в блоке `argument_specs`
(см. [Role argument validation](https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_roles.html#role-argument-validation)):

* `meta/main.yml`:
  ```yaml
  ---
  galaxy_info:
    ...
  
  dependencies:
    ...

  argument_specs:
    main:
      options:
        <имя_аргумента_1>:
          [description: <краткое описание аргумента>]
          required: <обязателен ли аргумент: true | false>
          type: <тип аргумента: str | int | float | bool | list | dict | bits | bytes | json | jsonarg | path | raw >
          [choices: <список возможных значений, если type == list>]
          [elememts: <тип элемента списка, если type == list>]
          [options: <описание структуры, если (type == dict) | (type == list & elements == dict)]
        <имя_аргумента_2>:
          ...
        <имя_аргумента_N>:
          ...
  ```

Для каждого аргумента обязательно определяются опции `required` и `type`. Остальные опции являются необязательными.

Если указывается тип аргумента `raw`, то тип входного значения для этого аргумента проверяться не будет.

Полное описание всех опций смотрите в [Specification format](https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_roles.html#specification-format).

Если роль не принимает никаких аргументов, то `argument_specs` задаётся _пустым_:

* `meta/main.yml`:
  ```yaml
  ---
  galaxy_info:
    ...
  
  dependencies:
    ...

  argument_specs:
  ```

Важные замечания:
* Для **обязательных** аргументов (`required: true`) необходимо следить за тем, чтобы они не определялись в `defaults/main.yml`.
  Иначе Ansible не заметит, что аргумент не задан при вызове роли и просто возьмёт значение по-умолчанию из `defaults/main.yml`.
* Для **необязательных** аргументов (`required: false`) можно указать значение по-умолчанию (опция `default`), но надо понимать,
  что фактическое значение по-умолчанию будет браться из `defaults/main.yml`.
* К сожалению, нельзя расчитывать на доскональную проверку типов аргументов. Проверка производится через попытку конвертировать входное значение
  аргумента в объявленный тип. И например, для аргумента типа `str` Ansible пропустит входное значение в виде списка. Потому что
  в Python список может автоматически конвертироваться в строку.

Пример роли с двумя обязательными аргументами, один из которых является списком словарей:

* плейбук:
  ```yaml
  ---
  - name: Установить стандартный набор апплетов
    hosts: 127.0.0.1
    connection: local

    roles:

      - role: applets
        vars:
          manager_port: 9999
          apps:
            - { name: app1, port: 8080, enabled: true, type: system, alias: main-app }
            - { name: app2, port: 8081, enabled: false, type: user }
        tags:
          - applets
  ```

* `roles/applets/meta/main.yml`:
  ```yaml
  ---
  galaxy_info:
    author: Radimir Mikhailov
    description: Install applets
    company: IT2G

    license: MIT

    min_ansible_version: 2.11

    platforms:
      - name: Alpine
        versions:
          - all
      - name: Debian
        versions:
          - all
      - name: EL
        versions:
          - all
      - name: Fedora
        versions:
          - all
      - name: Ubuntu
        versions:
          - all

    galaxy_tags: []

  dependencies: []

  argument_specs:
    main:
      options:
        manager_port:
          description: Порт, на котором располагается центр управления апплетами
          required: true
          type: str
        apps:
          description: Список апплетов
          required: true
          type: list
          elements: dict
          options:
            alias:
              description: Необязательный псевдоним апплета
              required: false
              type: str
            enabled:
              description: Статус апплета
              required: true
              type: bool
            name:
              description: Название апплета
              required: true
              type: str
            port:
              description: Порт апплета
              required: true
              type: int
            type:
              description: Тип апплета
              required: true
              type: str
              choices:
                - system
                - user
  ```

#### r2. Необязательные аргументы и подкаталог `defaults`

Значения по-умолчанию всех необязательных аргументов роли определяются в подкаталоге `defaults`.

Подкаталог `defaults` служит _только_ для определения необязательных аргументов.

* `meta/main.yml`:
  ```yaml
  ---
  ...
  argument_specs:
    main:
      options:
        service_name:
          description: Имя сервиса
          required: true
          type: str
        service_port:
          description: Порт, на котором располагается сервис
          required: false
          type: str
  ```

* `defaults/main.yml`:
  ```yaml
  ---
  service_port: 8000
  ```

#### r3. Приватные переменные и подкаталог `vars`

Приватные переменные роли — это переменные, которые определяются и используются исключительно
внутри роли. Значения этих переменных зависят только от внутренней логики самой роли.

Приватные переменные определяются в каталоге `vars`.

* `vars/main.yml`:
  ```yaml
  ---
  # Асболютный путь (без последнего слэша) к каталогу где хранятся PGP-ключи
  # репозиториев у соответствующего пакетного менеджера ОС
  _pgp_keys_path:
    apt: /etc/apt/trusted.gpg.d
    yum: /etc/pki/rpm-gpg

  _nexus_repo_docker_yum: docker-ce-centos7
  _nexus_repo_centos_extras: extras-centos7
  ```

#### r4. Область видимости переменных

Все переменные, определённые в роли, должны оставаться доступными только внутри роли.

Чтобы обеспечить это, необходимо включить параметр `private_role_vars` в конфигурации Ansible:

* `ansible.cfg`:
  ```ini
  [defaults]
  private_role_vars = true
  ```

Пример того, какой эффект оказывает этот параметр при использовании ролей:

* `roles/test/meta/main.yml`:
  ```yaml
  ---
  ...
  argument_specs:
    main:
      options:
        service_name:
          description: Имя сервиса
          required: true
          type: str
        service_port:
          description: Порт, на котором располагается сервис
          required: false
          type: str
  ```

* `roles/test/defaults/main.yml`:
  ```yaml
  ---
  service_port: 8000
  ```

* `roles/test/tasks/main.yml`:
  ```yaml
  ---
  - name: Install '{{ service_name }}'
    debug:
      var: service_port
  ```

* плейбук:
  ```yaml
  - hosts: 127.0.0.1
    connection: local
    gather_facts: false
    roles:

      - role: test
        vars:
          service_name: service_one
          service_port: 9999

      - role: test
        vars:
          service_name: service_two
          # ожидается, что service_port при выполнении этой роли примет значнение по-умолчанию (8000)
  ```

* Выполнение плейбука при `private_role_vars = false` (значение по-умолчанию):
  ```
  PLAY [127.0.0.1] *********************************************************************************

  TASK [test : Install 'service_one'] **************************************************************
  ok: [127.0.0.1] => {
      "service_port": 9999
  }

  TASK [test : Install 'service_two'] **************************************************************
  ok: [127.0.0.1] => {
      "service_port": 9999
  }
  ```

* Выполнение плейбука при `private_role_vars = true` (как должно быть):
  ```
  PLAY [127.0.0.1] *********************************************************************************

  TASK [test : Install 'service_one'] **************************************************************
  ok: [127.0.0.1] => {
      "service_port": 9999
  }

  TASK [test : Install 'service_two'] **************************************************************
  ok: [127.0.0.1] => {
      "service_port": 8000
  }
  ```

## Приложения

#### Приложение 1. Когда скаляр в YAML необходимо обрамлять в кавычки

Скаляр — это [YAML-узел](https://yaml.org/spec/1.2.2/#3211-nodes), представляющий единичное значение
— _строку_, _число_, _логическое значение_ или _null_.

Обрамлять скаляр в кавычки (**одинарные** `'` или **двойные** `"`) требуется:

* когда значение скаляра вступает в конфликт с синтаксисом YAML:

  * начинается со специального символа `!` `&` `*` `@` `%` `#` `|` `>` `` ` ``
  * начинается с символа `{` `}` `[` `]` `,` `"` `'` `<пробел>`
  * начинается с символа `-` `:` `?`, за которым следует пробел
  * _содержит_ в себе комбинации `:<пробел>` `<пробел>#`
  * _содержит_ в себе символы `{` `}` `[` `]` `,` при использовании [JSON-подобного синтаксиса](https://yaml.org/spec/1.2.2/#74-flow-collection-styles)
    (`[ {x: 1, y: 2, z: 3} ]`)
  * заканчивается символом `:`

  ```yaml
  TODO: пример
  ```

* когда значение скаляра должно однозначно интерпретироваться как строка, а не как _число_, _логическое_ значение или _null_:

  ```yaml
  TODO: пример
  ```

Дополнительно, если в строке используются [escape-последовательности](https://yaml.org/spec/1.2.2/#escaped-characters)
(`\t`, `\x1B`, `\u2029` и т.д.), то эту строку необходимо обрамлять в **двойные** кавычки `"`:

  ```yaml
  TODO: пример
  ```

Правила экранирования:

* строка **без** кавычек: нет необходимости экранировать - все символы отображаются как есть

* строка в **одинарных** кавычках `'`:
  * символа `'`: YAML: `sample: 'It''s my life'` → JSON: `{ "sample": "It's my life" }`
 
* строка в **двойных** кавычках `"`:
  * символа `"`: YAML: `sample: "My alias is \""` → JSON: `{ "sample": "It's my life" }`
  * символа `\`: YAML: `sample: "It's backslash: \\"` → JSON: `{ "sample": "It's backslash: \\" }`

Хорошая статья на тему обрамления в кавычки в YAML: [Quoting](https://www.yaml.info/learn/quote.html).
